<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <link rel="stylesheet" href="./style.css">
        <title>WebGL2</title>
    </head>
    <body>
        <div>
            <canvas id="canvas"></canvas>
        </div>
        <script src="./gl.js"></script>
        <script src="./Math.js"></script>
        <script src="./shaders.js"></script>
        <script src="./loop.js"></script>
        <script src="./transform.js"></script>
        <script src="./modal.js"></script>
        <script src="./primatives.js"></script>
        <script>
            let gl;
            let loop;
            let shader;
            let modal;

            window.addEventListener("load", () => {
                // Get our extended GL Context Object
                // and set up test shader
                gl = GLInstance("canvas")
                    .fSetSize(500, 500)
                    .fClear();
                shader = new TestShader(gl, [
                    0.8, 0.8, 0.8, // gray
                    1.0, 0.0, 0.0, // red
                    0.0, 1.0, 0.0, // green
                    0.0, 0.0, 1.0, // blue
                ]);

                // Set up modal
                modal = new Modal(primatives.GridAxis.createMesh(gl))
                    .setScale(0.4, 0.4, 0.4)
                    .setRotation(0.0, 0.0, 45.0)
                    .setPosition(0.8, 0.8, 0.0);

                // Set up for render
                loop = new Loop(render);
                loop.start();
            });

            function render(d) {
                const p = modal.transform.position; // just a pointer to transform position, make code smaller
                const angle = Math.atan2(p.y, p.x) + (1 * d); // calculate the current angle plue 1 degree per second rotation
                const radius = Math.sqrt(p.x * p.x + p.y * p.y); // calculate the distance from origin
                const scale = Math.max(0.2, Math.abs(Math.sin(angle)) * 1.2); // just messing with numbers and seeing what happens :)

                gl.fClear();
                shader.activate()
                    .renderModal(modal
                        .setScale(scale, scale / 4, 1)
                        .setPosition(radius * Math.cos(angle), radius * Math.sin(angle), 0)
                        .addRotation(30 * d, 60 * d, 15 * d)
                        .preRender()
                    );
            }

            class TestShader extends Shader {
                constructor(context, colors) {
                    super(context, ShaderUtil.loadShader("vertex"), ShaderUtil.loadShader("fragment"));

                    // Our shader uses custom uniforms
                    const uColor = context.getUniformLocation(this.program, 'u_color');
                    context.uniform3fv(uColor, colors);

                    context.useProgram(null);
                }
            }
        </script>
        <script id="vertex" type="x-shader/x-vertex">#version 300 es
            in vec3 a_position; // standard position data
            layout(location=4) in float a_color; // will hold the 4th custom position of the custom position buffer

            uniform mat4 u_modalViewMatrix;
            uniform vec3 u_color[4]; // color array

            out lowp vec4 color; // color output

            void main(void) {
                color = vec4(u_color[int(a_color)], 1.0); // using the 4th float as a color index
                gl_Position = u_modalViewMatrix * vec4(a_position, 1.0);
            }
        </script>
        <script id="fragment" type="x-shader/x-fragment">#version 300 es
            precision mediump float;

            in vec4 color;
            out vec4 final;

            void main(void) {
                final = color;
            }
        </script>
    </body>
</html>