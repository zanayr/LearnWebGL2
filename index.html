<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <link rel="stylesheet" href="./style.css">
        <title>WebGL2</title>
    </head>
    <body>
        <div>
            <canvas id="canvas"></canvas>
        </div>
        <script src="./gl.js"></script>
        <script src="./Math.js"></script>
        <script src="./shaders.js"></script>
        <script src="./loop.js"></script>
        <script src="./transform.js"></script>
        <script src="./modal.js"></script>
        <script src="./primatives.js"></script>
        <script src="./camera.js"></script>
        <script src="./shader_extra.js"></script>
        <script>
            let gl;
            let loop;
            let shader;
            let modal;
            let modal2;
            let camera;
            let controller;
            let gridShader;
            let gridModal;

            window.addEventListener("load", () => {
                // Main setup
                gl = GLInstance("canvas")
                    .fFitScreen(1, 1)
                    .fClear();
                camera = new Camera(gl);
                camera.transform.position.set(0.0, 1.0, 3.0);
                controller = new CameraController(gl, camera);
                
                // Setup grid
                gridShader = new GridAxisShader(gl, camera.projectionMatrix);
                gridModal = primatives.GridAxis.createModal(gl, true);

                // Setup test shader, modal and meshes
                shader = new TestShader(gl, camera.projectionMatrix);
                modal = primatives.MultiQuad.createModal(gl);
                // modal.setPosition(0.0, 1.0, 0.0).setScale(0.2, 0.2, 0.2);

                // modal2 = new Modal(gl.mMeshCache["Quad"]); // extra, show 2 modals sharing one mesh

                // Set up for render
                loop = new Loop(render);
                loop.start();
            });

            function render(d) {
                camera.updateViewMatrix();

                gl.fClear();
                gridShader.activate()
                    .setCameraMatrix(camera.viewMatrix)
                    .renderModal(gridModal.preRender());

                shader.activate()
                    .setCameraMatrix(camera.viewMatrix)
                    .renderModal( modal.preRender() )
                    // .renderModal( modal2.preRender() );
            }

            class TestShader extends Shader {
                constructor(context, matrix) {
                    super(context, ShaderUtil.loadShader("vertex"), ShaderUtil.loadShader("fragment"));

                    this.setPerspective(matrix);
                    context.useProgram(null);
                }
            }
        </script>
        <script id="vertex" type="x-shader/x-vertex">#version 300 es
            in vec3 a_position;
            in vec2 a_uv;

            uniform mat4 u_projectionMatrix;
            uniform mat4 u_cameraMatrix;
            uniform mat4 u_modalViewMatrix;

            out vec2 uv;

            void main(void) {
                uv = a_uv;
                gl_Position = u_projectionMatrix * u_cameraMatrix * u_modalViewMatrix * vec4(a_position, 1.0);
            }
        </script>
        <script id="fragment" type="x-shader/x-fragment">#version 300 es
            precision mediump float;

            in vec2 uv;

            out vec4 final;

            void main(void) {
                float color = (uv.x <= 0.1 || uv.x >= 0.9 || uv.y <= 0.1 || uv.y >= 0.9) ? 0.0 : 1.0;
                final = vec4(color, color, color, 1.0 - color);

                // Circle
                /*
                vec2 delta = uv - vec2(0.5, 0.5); // delta position from center
                float distance = 0.5 - sqrt(delta.x * delta.x + delta.y * delta.y);

                float border = 0.01;
                float alpha = 0.0;
                if (distance > border) alpha = 1.0;
                else if (distance > 0.0) alpha = distance / border;

                final = vec4(0.0, 0.0, 0.0, alpha);
                */
            }
        </script>
    </body>
</html>